package espdb;

import java.io.IOException;
import java.io.PrintStream;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;

import sys.Env;
import sys.Log;
import text.tokenize.BasicTokenizer;

public class DataBase {
	Connection connection = null;
	public String lastq=null;

	public static class Result {
		private Statement statement;
		private boolean hasResult;
		private int updCnt=-1;
		private int genKey=-1;

		public boolean hasMore() {
			return hasResult || updCnt >= 0;
		}
		public int getGenKey() { return genKey; }
		public boolean hasResult() { return hasResult; }
		public boolean moreResults() throws SQLException {
			if (statement == null) return false;
			hasResult = statement.getMoreResults();
			updCnt = statement.getUpdateCount();
			return hasMore();
		}

		public ResultSet getResultSet() throws SQLException {
			return statement.getResultSet();
		}

		public void close() {
			if (statement!=null) {
				try {statement.close();}
				catch (SQLException e) {}
				statement = null;
			}
			hasResult = false;
			updCnt = -1;
		}

		@Override
		protected void finalize() throws Throwable {
			close();
			super.finalize();
		}
	}

	public DataBase(String dbname) throws SQLException {
		connection = DriverManager.getConnection(dbname);
	}
	public DataBase(String dbname, String user, String passwd) throws SQLException {
		connection = DriverManager.getConnection(dbname, user, passwd);
	}

	public Result query(String q) throws SQLException {
		if (q.isEmpty()) return null;
		lastq=q;
		int opt = 0;
		if (q.toUpperCase().startsWith("INSERT"))
			opt = Statement.RETURN_GENERATED_KEYS;
		Result r = new Result();
		r.statement = connection.createStatement();

		if (opt == Statement.RETURN_GENERATED_KEYS) {
			ResultSet genkeys;
			//sqlite don't support execute(q, opt)
			if (connection.getMetaData().getDatabaseProductName().equals("SQLite")) {
				r.hasResult = r.statement.execute(q);
				r.updCnt = r.statement.getUpdateCount();
				genkeys = r.statement.executeQuery("SELECT last_insert_rowid()");
			}
			else {
				r.hasResult = r.statement.execute(q, opt);
				r.updCnt = r.statement.getUpdateCount();
				genkeys = r.statement.getGeneratedKeys();
			}
			if (genkeys.next()) {
				r.genKey = genkeys.getInt(1);
				Log.debug("autoGeneratedKey = %d",r.genKey);
			}
			else r.genKey=-1;
		}
		else {
			r.hasResult = r.statement.execute(q);
			r.updCnt = r.statement.getUpdateCount();
		}
		return r;
	}

	public Result query(String q, Object... args) throws SQLException {
		lastq=q+"("+args+")";
		Result r = new Result();
		int opt = Statement.NO_GENERATED_KEYS;
		if (q.toUpperCase().contains("INSERT"))
			opt = Statement.RETURN_GENERATED_KEYS;
		PreparedStatement pstmt = connection.prepareStatement(q, opt);
		r.statement = pstmt;
		int i = 1;
		for(Object a : args) {
			pstmt.setObject(i++, a);
		}
		r.hasResult = pstmt.execute();
		r.updCnt = r.statement.getUpdateCount();
		if (r.updCnt > 0) {
			ResultSet k = r.statement.getGeneratedKeys();
			if (k.next()) {
				r.genKey = k.getInt(1);
			}
		}
		return r;
	}

	public Result script(String script) throws SQLException,IOException {
		//TODO SQL tokenizer
		BasicTokenizer tok = new BasicTokenizer(script);
		tok.setDelimiter(";");
		StringBuilder b = new StringBuilder();
		Result r = null;
		try {
			while (tok.next(b)) {
				String q = b.toString().trim();
				q = q.replaceAll("--.*\n", "");
				if (q.equals(";")) continue;
				Log.debug("script: '%s'", q);
				if (r != null) r.close();
				r = query(q);
			}
		}catch(SQLException e) {
			if (lastq != null) Log.error(lastq);
			throw e;
		}
		return r;
	}

	static private void printHead(ResultSet rs, PrintStream out) throws SQLException {
		ResultSetMetaData meta = rs.getMetaData();
		int cols = meta.getColumnCount();
		out.print("|");
		for (int i=1; i <= cols; ++i) {
			out.print(meta.getColumnLabel(i)+":"+meta.getColumnTypeName(i)+"|");
		}
		out.println();
	}
	static private void printRow(ResultSet rs, PrintStream out) throws SQLException {
		ResultSetMetaData meta = rs.getMetaData();
		int cols = meta.getColumnCount();
		out.print("|");
		for (int i=1; i <= cols; ++i) {
			out.print(rs.getString(i)+"|");
		}
		out.println();
	}

	static public void print(Result r, PrintStream out) throws SQLException {
		while(r.hasMore()) {
			if (r.hasResult()) {
				ResultSet rs = r.getResultSet();
				printHead(rs, out);
				while (rs.next())
					printRow(rs, out);
				rs.close();
			}
			else {
				out.println("updated rows " + r.updCnt);
			}
			out.println("--------------------");
			r.moreResults();
		}
		r.close();
	}

	//https://en.wikipedia.org/wiki/Grammatical_conjugation
	static String[] scipts = {
		"word.sql",
		"conjugation.sql","person.sql","tense.sql",
		//"word_core.sql", "word_core_rel.sql"
		"word_lang_rel.sql",
		};

	public static void main(String[] args) throws Exception {
		Class.forName("org.sqlite.JDBC");

		Env.remove("res/espdb.db");
		DataBase db = new DataBase("jdbc:sqlite:res/espdb.db");
		db.query("");

		Result r;
		for (String s : scipts) {
			r = db.script(Env.getFileContent("~/www/espdb/sql/" + s));
			r.close();
		}

		r = db.query("INSERT INTO word_es (word)VALUES (?)", "los;");
		print(r,System.out);
		r.close();

		r = db.query("SELECT * FROM word_es");
		print(r,System.out);
		r.close();
	}
}
